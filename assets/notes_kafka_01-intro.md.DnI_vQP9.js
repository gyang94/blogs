import{_ as e,c as t,o as r,ae as o}from"./chunks/framework.Bk39dawk.js";const i="/blogs/assets/point-to-point.MeV0r5wE.png",l="/blogs/assets/publisher-subscriber.BZ_iDV46.png",u=JSON.parse('{"title":"Kafka简介","description":"","frontmatter":{"title":"Kafka简介","tags":"Kafka","outline":"deep"},"headers":[],"relativePath":"notes/kafka/01-intro.md","filePath":"notes/kafka/01-intro.md","lastUpdated":1740754666000}'),n={name:"notes/kafka/01-intro.md"};function s(h,a,p,d,c,_){return r(),t("div",null,a[0]||(a[0]=[o('<h1 id="kafka简介" tabindex="-1">Kafka简介 <a class="header-anchor" href="#kafka简介" aria-label="Permalink to &quot;Kafka简介&quot;">​</a></h1><h2 id="_1-概述" tabindex="-1">1. 概述 <a class="header-anchor" href="#_1-概述" aria-label="Permalink to &quot;1. 概述&quot;">​</a></h2><p>Kafka是最初由Linkedin公司开发，是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统（也可以当做MQ系统），常见可以用于web/nginx日志、访问日志，消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。</p><p>主要应用场景是：日志收集系统和消息系统。</p><p>Kafka主要设计目标如下：</p><ul><li>以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间的访问性能。</li><li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条消息的传输。</li><li>支持Kafka Server间的消息分区，及分布式消费，同时保证每个partition内的消息顺序传输。</li><li>同时支持离线数据处理和实时数据处理。</li><li>Scale out:支持在线水平扩展</li></ul><h2 id="_2-消息系统" tabindex="-1">2. 消息系统 <a class="header-anchor" href="#_2-消息系统" aria-label="Permalink to &quot;2. 消息系统&quot;">​</a></h2><p>一个消息系统负责将数据从一个应用传递到另外一个应用，应用只需关注于数据，无需关注数据在两个或多个应用间是如何传递的。分布式消息传递基于可靠的消息队列，在客户端应用和消息系统之间异步传递消息。有两种主要的消息传递模式：<strong>点对点传递模式、发布-订阅模式</strong>。大部分的消息系统选用发布-订阅模式。<strong>Kafka就是一种发布-订阅模式</strong>。</p><h3 id="_2-1-点对点消息传递模式" tabindex="-1">2.1 点对点消息传递模式 <a class="header-anchor" href="#_2-1-点对点消息传递模式" aria-label="Permalink to &quot;2.1 点对点消息传递模式&quot;">​</a></h3><p>在点对点消息系统中，消息持久化到一个队列中。此时，将有一个或多个消费者消费队列中的数据。但是一条消息只能被消费一次。当一个消费者消费了队列中的某条数据之后，该条数据则从消息队列中删除。该模式即使有多个消费者同时消费数据，也能保证数据处理的顺序。这种架构描述示意图如下：</p><p><img src="'+i+'" alt="点对点模式" title="点对点模式"></p><p><strong>生产者发送一条消息到queue，只有一个消费者能收到</strong>。</p><h3 id="_2-2-发布-订阅消息传递模式" tabindex="-1">2.2 发布-订阅消息传递模式 <a class="header-anchor" href="#_2-2-发布-订阅消息传递模式" aria-label="Permalink to &quot;2.2 发布-订阅消息传递模式&quot;">​</a></h3><p>在发布-订阅消息系统中，消息被持久化到一个topic中。与点对点消息系统不同的是，消费者可以订阅一个或多个topic，消费者可以消费该topic中所有的数据，同一条数据可以被多个消费者消费，数据被消费后不会立马删除。在发布-订阅消息系统中，消息的生产者称为发布者，消费者称为订阅者。该模式的示例图如下：</p><p><img src="'+l+'" alt="点发布-订阅模式" title="发布-订阅模式"></p><p><strong>发布者发送到topic的消息，只有订阅了topic的订阅者才会收到消息</strong>。</p><h2 id="_3-kafka的优点" tabindex="-1">3. Kafka的优点 <a class="header-anchor" href="#_3-kafka的优点" aria-label="Permalink to &quot;3. Kafka的优点&quot;">​</a></h2><h3 id="_3-1-解耦" tabindex="-1">3.1 解耦 <a class="header-anchor" href="#_3-1-解耦" aria-label="Permalink to &quot;3.1 解耦&quot;">​</a></h3><p>在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p><h3 id="_3-2-冗余" tabindex="-1">3.2 冗余 <a class="header-anchor" href="#_3-2-冗余" aria-label="Permalink to &quot;3.2 冗余&quot;">​</a></h3><p>有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的&quot;插入-获取-删除&quot;范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</p><h3 id="_3-3-扩展性" tabindex="-1">3.3 扩展性 <a class="header-anchor" href="#_3-3-扩展性" aria-label="Permalink to &quot;3.3 扩展性&quot;">​</a></h3><p>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。</p><h3 id="_3-4-灵活性-峰值处理能力" tabindex="-1">3.4 灵活性&amp;峰值处理能力 <a class="header-anchor" href="#_3-4-灵活性-峰值处理能力" aria-label="Permalink to &quot;3.4 灵活性&amp;峰值处理能力&quot;">​</a></h3><p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p><h3 id="_3-5-可恢复性" tabindex="-1">3.5 可恢复性 <a class="header-anchor" href="#_3-5-可恢复性" aria-label="Permalink to &quot;3.5 可恢复性&quot;">​</a></h3><p>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p><h3 id="_3-6-顺序保证" tabindex="-1">3.6 顺序保证 <a class="header-anchor" href="#_3-6-顺序保证" aria-label="Permalink to &quot;3.6 顺序保证&quot;">​</a></h3><p>在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。Kafka保证一个Partition内的消息的有序性。</p><h3 id="_3-7-缓冲" tabindex="-1">3.7 缓冲 <a class="header-anchor" href="#_3-7-缓冲" aria-label="Permalink to &quot;3.7 缓冲&quot;">​</a></h3><p>在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速。该缓冲有助于控制和优化数据流经过系统的速度。</p><h3 id="_3-8-异步通信" tabindex="-1">3.8 异步通信 <a class="header-anchor" href="#_3-8-异步通信" aria-label="Permalink to &quot;3.8 异步通信&quot;">​</a></h3><p>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p>',33)]))}const f=e(n,[["render",s]]);export{u as __pageData,f as default};
