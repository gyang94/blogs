import{_ as a,c as t,o as r,ae as o}from"./chunks/framework.Bk39dawk.js";const c=JSON.parse('{"title":"Paimon","description":"","frontmatter":{"title":"Paimon","tags":"Paimon","outline":"deep"},"headers":[],"relativePath":"notes/paimon/02-lsm.md","filePath":"notes/paimon/02-lsm.md","lastUpdated":1750348555000}'),s={name:"notes/paimon/02-lsm.md"};function l(n,e,i,p,m,d){return r(),t("div",null,e[0]||(e[0]=[o('<h1 id="lsm-tree-结构化日志合并树" tabindex="-1">LSM-Tree 结构化日志合并树 <a class="header-anchor" href="#lsm-tree-结构化日志合并树" aria-label="Permalink to &quot;LSM-Tree 结构化日志合并树&quot;">​</a></h1><h2 id="lsm-tree" tabindex="-1">LSM Tree <a class="header-anchor" href="#lsm-tree" aria-label="Permalink to &quot;LSM Tree&quot;">​</a></h2><h3 id="从关系型数据库说起" tabindex="-1">从关系型数据库说起 <a class="header-anchor" href="#从关系型数据库说起" aria-label="Permalink to &quot;从关系型数据库说起&quot;">​</a></h3><p>传统关系型数据库通常在读性能上有较高的要求，通过在特定范围内进行复杂、简单读场景下进行高效的查找。</p><ol><li>关系型数据库在读性能上有很高的要求（比如电商、金融通常人们说吞吐量、或者说查询太慢）。</li><li>关系型数据库在一定程度的数据规模下能够支持事务、快速的在线联机处理，在特定的复杂查询场景下能够高效的检索。</li><li>二分查找、hash、索引、B+树信息强加在了数据上，数据必须按照特定的方式存储。这样就有一个缺陷就是涉及到了磁盘的随机写。逻辑上很近的数据物理上可能很远，就可能造成大量的磁盘随机写，严重影响写操作性能。</li></ol><p>总结： 关系型数据库相比较看重的是读性能。通过二分查找、hash、B+树等是数据查询更快，但是底层磁盘的存储造成了大量的随机写。虽说电商、金融等行业业务数据量大、但是针对我们后端接口等操作的适合只是其中部分具有固定场景的查询（索引、where）。</p><h3 id="lsm-tree-特性" tabindex="-1">LSM Tree 特性 <a class="header-anchor" href="#lsm-tree-特性" aria-label="Permalink to &quot;LSM Tree 特性&quot;">​</a></h3><p>因为磁盘随机操作慢，顺序读写快的特性，如果要提高写操作性能，避免随机写，设计成顺序写。</p><p>顺序写简单，直接将数据追加的方式写入文件，因为完全是顺序的，所以性能很好。</p><p>但是读取却要花费很多时间。因为查询具体的内容需要扫描所有数据。通过上述分析得出如果要高效的读和写其实要根据具体的场景做一个权衡。所以LSM-Tree诞生了。</p><p>LSM-Tree全称是Log Structured Merge Tree，是一种分层，有序，面向磁盘的数据结构，其核心思想是充分了利用磁盘批量的顺序写要远比随机写性能高出很多。</p><p>发挥磁盘的特性：一次性地读取或写入固定大小的一批数据，并尽可能地减少随机寻道操作。</p><p>LSM-Tree 结构除了<strong>利用磁盘顺序写实现高性能写</strong>，也通过<strong>划分内存+磁盘的多层合并结构</strong>及各种优化实现尽量保证读性能。</p><p>传统关系型数据库查询的一般将数据库当作一个整体去查找我们想要的数据, 但<strong>LSM 树通过这些有序文件实现了（管理一组索引、快照文件而不是单一的索引文件，并且推迟和批量地进行数据更新），充分利用内存来存储近期或常用数据以提高读效率，索引、快照文件也是按照时间顺序来存储数据（这也是为什么paimon、hudi通过spark、flink做实时依然很快），利用硬盘存储不常用数据以减少存储代价。</strong></p>',14)]))}const _=a(s,[["render",l]]);export{c as __pageData,_ as default};
